# Importar librerías necesarias
import pandas as pd
import numpy as np
from sklearn.model_selection import train_test_split
from sklearn.neighbors import KernelDensity
from sklearn.metrics import accuracy_score
from sklearn.datasets import load_wine
import matplotlib.pyplot as plt

# Cargar el dataset Wine
data = load_wine()
X = pd.DataFrame(data.data, columns=data.feature_names)
y = pd.DataFrame(data.target, columns=['target'])

# Dividir los datos en conjunto de entrenamiento y prueba
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Asegurarse de que no haya valores nulos en los datos
X_train = X_train.fillna(X_train.mean())
X_test = X_test.fillna(X_test.mean())

# Crear modelos KDE para cada clase del target
models = {}
for label in np.unique(y_train.values.flatten()):
    kde = KernelDensity(kernel='gaussian', bandwidth=0.5)
    kde.fit(X_train[y_train.values.flatten() == label])
    models[label] = kde

# Calcular las probabilidades logarítmicas para los datos de prueba
log_probs = {}
for label, model in models.items():
    log_probs[label] = model.score_samples(X_test)

# Predecir la clase más probable para cada muestra
log_probs_matrix = np.vstack([log_probs[label] for label in models]).T
y_pred = np.argmax(log_probs_matrix, axis=1)

# Evaluar el rendimiento del modelo
accuracy = accuracy_score(y_test, y_pred)
print(f"Exactitud del modelo probabilístico (KDE): {accuracy}")

# Graficar la distribución de las clases para una visualización adicional
plt.figure(figsize=(8, 6))
plt.hist(y_pred, bins=np.arange(0, 4) - 0.5, rwidth=0.8, color='orange', label='Predicciones', alpha=0.7)
plt.hist(y_test.values.flatten(), bins=np.arange(0, 4) - 0.5, rwidth=0.4, color='blue', label='Valores reales', alpha=0.7)
plt.xticks([0, 1, 2])
plt.xlabel("Clases")
plt.ylabel("Frecuencia")
plt.title("Distribución de Predicciones vs Valores Reales")
plt.legend()

# Guardar la gráfica en el repositorio
output_path = "Distribucion_Predicciones_vs_Valores_Reales.png"
plt.savefig(output_path)  # Guardar la gráfica en el archivo
print(f"Gráfica guardada como {output_path}")
plt.show()
